struct VIn {
    float4 p    : POSITION;
    float3 n    : NORMAL;
    float2 uv   : TEXCOORD0;
    float2 lightMapUV : TEXCOORD1;
    float3 t : TANGENT0;
};

struct VOut {
    float4 p    : POSITION;
    float2 uv   : TEXCOORD0;
    float4 wp   : TEXCOORD1;
    float3 n    : TEXCOORD2;
    float4 lp   : TEXCOORD3;
    float3 sdir : TEXCOORD4;
    float2 lightMapUV : TEXCOORD5;
//    float3 tan : TEXCOORD6;
    float3 oLightDir0  	: TEXCOORD6;
};

struct PIn {
    float2 uv   : TEXCOORD0;
    float4 wp   : TEXCOORD1;
    float3 n    : TEXCOORD2;
    float4 lp   : TEXCOORD3;
    float3 sdir : TEXCOORD4;
    float2 lightMapUV   : TEXCOORD5;
    float3 LightDir0 : TEXCOORD6;
};

struct POut {
    float4 c : COLOR;
};

VOut diffuse_vs(VIn IN,
    uniform float4x4 wMat,
    uniform float4x4 wvpMat,
    uniform float4x4 tvpMat,
    uniform float4 spotlightDir,
    //uniform float4 lightPosition,
    uniform float4 lightPosition0,
    uniform float scaleU,
    uniform float scaleV

    ) {

    VOut OUT;
    OUT.wp = mul(wMat, IN.p);
    OUT.p = mul(wvpMat, IN.p);

        
    float2 uvScale;
    uvScale.x = scaleU;
    uvScale.y = scaleV;

    OUT.uv = IN.uv * uvScale;
    //OUT.uv = uvScale;

    OUT.n = mul(wMat, float4(IN.n, 0)).xyz; // world-space normal
    OUT.sdir = mul(wMat, spotlightDir).xyz; // spotlight dir in world space
    OUT.lp = mul(tvpMat, OUT.wp);
    OUT.lightMapUV = IN.lightMapUV;	
    //OUT.tan = IN.t;    
//	OUT.tan = mul(wMat, float4(IN.t, 0)).xyz;

        float3 binormal = cross(IN.t, IN.n);
        float3x3 rotation = float3x3(IN.t, binormal, IN.n);

        float3 temp_lightDir0 = normalize(lightPosition0.xyz -  (IN.p * lightPosition0.w));
        temp_lightDir0 = normalize(mul(rotation, temp_lightDir0));
        OUT.oLightDir0 = temp_lightDir0;	


    return OUT;
}


float2 btex2D_rg(sampler2D map, float2 uv, float radius, float2 offset) {
    // this is sometimes too slow and long
    // (3 * 2 + 1) ^ 2 =  7 ^ 2 = 49 samples
//    float2 sample = float2(0, 0);
//    for (float x = -radius; x <= radius; x += 1) {
//        for (float y = -radius; y <= radius; y += 1) {
//            sample += tex2D(map, float2(uv.x + x * offset.x, uv.y + y * offset.y)).rg;
//        }
//    }
//    return sample / ((radius * 2 + 1) * (radius * 2 + 1));

    // simple 3x3 filter
    float2 o = offset;
    float2 c = tex2D(map, uv.xy).rg; // center
    c += tex2D(map, uv.xy - o.xy).rg; // top left
    c += tex2D(map, uv.xy + o.xy).rg; // bottom right
    c += tex2D(map, float2(uv.x - o.x, uv.y)).rg; // left
    c += tex2D(map, float2(uv.x + o.x, uv.y)).rg; // right
    c += tex2D(map, float2(uv.x, uv.y + o.y)).rg; // bottom
    c += tex2D(map, float2(uv.x, uv.y - o.y)).rg; // top
    c += tex2D(map, float2(uv.x - o.x, uv.y + o.y)).rg; // bottom left
    c += tex2D(map, float2(uv.x + o.x, uv.y - o.y)).rg; // top right
    return c / 9;
}

float shadow(
    sampler2D shadowMap, float4 shadowMapPos, float ourDepth, float radius, float2 offset) {
    float2 suv = shadowMapPos.xy / shadowMapPos.w;

    float2 moments = //tex2D(shadowMap, suv).rg;
    // blurred texture read
    btex2D_rg(shadowMap, suv, radius, offset);
    float litFactor = (ourDepth <= moments.x ? 1 : 0);

    // standard variance shadow mapping code
    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float vsmEpsilon = 0.0001;
    float variance = min(max(E_x2 - Ex_2, 0.0) + vsmEpsilon, 1.0);
    float m_d = moments.x - ourDepth;
    float p = variance / (variance + m_d * m_d);

    return smoothstep(0.4, 1, max(litFactor, p));
    //return litFactor;
}

// Expand a range-compressed vector
float3 expand(float3 v)
{
	return (v - 0.5) * 2;
}


// to put it simply, this does 100% per pixel diffuse lighting
POut diffuse_ps(PIn IN,
    uniform float3 lightDif0,
    uniform float4 lightPos0,
    uniform float4 lightAtt0,
    uniform float4 depthRange,
    uniform float4 invSMSize,
    uniform float4 spotlightParams,

    uniform sampler2D dMap : TEXUNIT0,
    uniform sampler2D lmMap : TEXUNIT1,
    //uniform sampler2D shadowMap : TEXUNIT2,
    uniform sampler2D normalHeightMap : TEXUNIT3
    //uniform samplerCUBE normalizeCube

    ) {

    POut OUT;

    // direction
    float3 ld0 = normalize(lightPos0.xyz - (lightPos0.w * IN.wp.xyz));

    // attenuation
    half ila = length(lightPos0.xyz - IN.wp.xyz) / lightAtt0.r;
    ila *= ila; // quadratic falloff
    half la = 1.0 - ila;

    float3 normal = normalize(IN.n);

    float3 LdotN0 = max(dot(ld0, normal), 0);
    float4 difTex = tex2D(dMap, IN.uv);

    // calculate the spotlight effect
    float spot = dot(ld0, normalize(-IN.sdir)); // angle between spotlight dir and actual dir
    spot = saturate((spot - spotlightParams.y) / (spotlightParams.x - spotlightParams.y));

//------------------------------------------------------------------------------
//normal map code


        float3 bumpVec = expand(tex2D(normalHeightMap, IN.uv).xyz);
        float3 N = normalize(bumpVec);
        float NdotL0 = dot(normalize(IN.LightDir0), N);
        float normalMap;
        normalMap = saturate(NdotL0);


//------------------------------------------------------------------------------

    // Lightmap
    //float atten2=0;
    //atten2 = tex2D(lmMap, IN.uv).x;
    float4 lmColor = tex2D(lmMap, IN.lightMapUV) * 1.8;
    


//	float3 light0C = difTex.xyz * la * (spot * lmColor * normalMap * 2.1);
//	float3 light0C = difTex * (spot * lmColor * normalMap * 2.1);
	float3 light0C = difTex; // * (lmColor * normalMap * 2.1);

	OUT.c = float4(light0C, 1); // * lmColor
	// + atten2

//POut OUT;
//OUT.c = float4(N, 1);
//OUT.c = difTex * lmColor;
//OUT.c =  lmColor;
//return OUT;


    return OUT;
}
